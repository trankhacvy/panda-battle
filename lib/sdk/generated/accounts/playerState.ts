/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';

export const PLAYER_STATE_DISCRIMINATOR = new Uint8Array([
  56, 3, 60, 86, 174, 16, 244, 195,
]);

export function getPlayerStateDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    PLAYER_STATE_DISCRIMINATOR
  );
}

export type PlayerState = {
  discriminator: ReadonlyUint8Array;
  /** Player's wallet address */
  player: Address;
  /** Reference to the game round */
  round: Address;
  /** Strength attribute (damage output) */
  str: number;
  /** Agility attribute (turn order, dodge chance, crit chance) */
  agi: number;
  /** Intelligence attribute (damage mitigation) */
  int: number;
  /** Current level (0-10, starts at 0) */
  level: number;
  /** Current experience points */
  xp: number;
  /** Leaderboard points (wins = +1 point) */
  points: number;
  /** Current available turns */
  turns: number;
  /** Maximum turn storage (default 50) */
  maxTurns: number;
  /** Last turn regeneration timestamp */
  lastTurnRegen: bigint;
  /** Number of rerolls used (max 3) */
  rerollsUsed: number;
  /** Number of attack packs bought in current hour */
  packsBoughtHour: number;
  /** Last hour when pack was bought (unix timestamp) */
  lastPackHour: bigint;
  /** Last battle/action timestamp */
  lastBattle: bigint;
  /** Total battles fought */
  battlesFought: number;
  /** Battles won */
  wins: number;
  /** Battles lost */
  losses: number;
  /** Prize share for this round (calculated at end) */
  prizeShare: bigint;
  /** Whether prize has been claimed */
  prizeClaimed: boolean;
  /** When player joined the round */
  joinedAt: bigint;
  /** Entry fee paid (for tracking) */
  entryFeePaid: bigint;
  delegated: boolean;
  /** Bump seed for PDA */
  bump: number;
};

export type PlayerStateArgs = {
  /** Player's wallet address */
  player: Address;
  /** Reference to the game round */
  round: Address;
  /** Strength attribute (damage output) */
  str: number;
  /** Agility attribute (turn order, dodge chance, crit chance) */
  agi: number;
  /** Intelligence attribute (damage mitigation) */
  int: number;
  /** Current level (0-10, starts at 0) */
  level: number;
  /** Current experience points */
  xp: number;
  /** Leaderboard points (wins = +1 point) */
  points: number;
  /** Current available turns */
  turns: number;
  /** Maximum turn storage (default 50) */
  maxTurns: number;
  /** Last turn regeneration timestamp */
  lastTurnRegen: number | bigint;
  /** Number of rerolls used (max 3) */
  rerollsUsed: number;
  /** Number of attack packs bought in current hour */
  packsBoughtHour: number;
  /** Last hour when pack was bought (unix timestamp) */
  lastPackHour: number | bigint;
  /** Last battle/action timestamp */
  lastBattle: number | bigint;
  /** Total battles fought */
  battlesFought: number;
  /** Battles won */
  wins: number;
  /** Battles lost */
  losses: number;
  /** Prize share for this round (calculated at end) */
  prizeShare: number | bigint;
  /** Whether prize has been claimed */
  prizeClaimed: boolean;
  /** When player joined the round */
  joinedAt: number | bigint;
  /** Entry fee paid (for tracking) */
  entryFeePaid: number | bigint;
  delegated: boolean;
  /** Bump seed for PDA */
  bump: number;
};

/** Gets the encoder for {@link PlayerStateArgs} account data. */
export function getPlayerStateEncoder(): FixedSizeEncoder<PlayerStateArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['player', getAddressEncoder()],
      ['round', getAddressEncoder()],
      ['str', getU8Encoder()],
      ['agi', getU8Encoder()],
      ['int', getU8Encoder()],
      ['level', getU8Encoder()],
      ['xp', getU32Encoder()],
      ['points', getU16Encoder()],
      ['turns', getU8Encoder()],
      ['maxTurns', getU8Encoder()],
      ['lastTurnRegen', getI64Encoder()],
      ['rerollsUsed', getU8Encoder()],
      ['packsBoughtHour', getU8Encoder()],
      ['lastPackHour', getI64Encoder()],
      ['lastBattle', getI64Encoder()],
      ['battlesFought', getU16Encoder()],
      ['wins', getU16Encoder()],
      ['losses', getU16Encoder()],
      ['prizeShare', getU64Encoder()],
      ['prizeClaimed', getBooleanEncoder()],
      ['joinedAt', getI64Encoder()],
      ['entryFeePaid', getU64Encoder()],
      ['delegated', getBooleanEncoder()],
      ['bump', getU8Encoder()],
    ]),
    (value) => ({ ...value, discriminator: PLAYER_STATE_DISCRIMINATOR })
  );
}

/** Gets the decoder for {@link PlayerState} account data. */
export function getPlayerStateDecoder(): FixedSizeDecoder<PlayerState> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['player', getAddressDecoder()],
    ['round', getAddressDecoder()],
    ['str', getU8Decoder()],
    ['agi', getU8Decoder()],
    ['int', getU8Decoder()],
    ['level', getU8Decoder()],
    ['xp', getU32Decoder()],
    ['points', getU16Decoder()],
    ['turns', getU8Decoder()],
    ['maxTurns', getU8Decoder()],
    ['lastTurnRegen', getI64Decoder()],
    ['rerollsUsed', getU8Decoder()],
    ['packsBoughtHour', getU8Decoder()],
    ['lastPackHour', getI64Decoder()],
    ['lastBattle', getI64Decoder()],
    ['battlesFought', getU16Decoder()],
    ['wins', getU16Decoder()],
    ['losses', getU16Decoder()],
    ['prizeShare', getU64Decoder()],
    ['prizeClaimed', getBooleanDecoder()],
    ['joinedAt', getI64Decoder()],
    ['entryFeePaid', getU64Decoder()],
    ['delegated', getBooleanDecoder()],
    ['bump', getU8Decoder()],
  ]);
}

/** Gets the codec for {@link PlayerState} account data. */
export function getPlayerStateCodec(): FixedSizeCodec<
  PlayerStateArgs,
  PlayerState
> {
  return combineCodec(getPlayerStateEncoder(), getPlayerStateDecoder());
}

export function decodePlayerState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<PlayerState, TAddress>;
export function decodePlayerState<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<PlayerState, TAddress>;
export function decodePlayerState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<PlayerState, TAddress> | MaybeAccount<PlayerState, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getPlayerStateDecoder()
  );
}

export async function fetchPlayerState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<PlayerState, TAddress>> {
  const maybeAccount = await fetchMaybePlayerState(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybePlayerState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<PlayerState, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodePlayerState(maybeAccount);
}

export async function fetchAllPlayerState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<PlayerState>[]> {
  const maybeAccounts = await fetchAllMaybePlayerState(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybePlayerState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<PlayerState>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodePlayerState(maybeAccount));
}

export function getPlayerStateSize(): number {
  return 143;
}
