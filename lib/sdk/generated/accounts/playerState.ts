/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';

export const PLAYER_STATE_DISCRIMINATOR = new Uint8Array([
  56, 3, 60, 86, 174, 16, 244, 195,
]);

export function getPlayerStateDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    PLAYER_STATE_DISCRIMINATOR
  );
}

export type PlayerState = {
  discriminator: ReadonlyUint8Array;
  /** Player's wallet address */
  player: Address;
  /** Reference to the game round */
  round: Address;
  /** Strength attribute (damage output) */
  strength: number;
  /** Speed attribute (turn order, dodge chance) */
  speed: number;
  /** Endurance attribute (HP, damage absorption) */
  endurance: number;
  /** Luck attribute (crit chance, steal success) */
  luck: number;
  /** Current available turns */
  turns: number;
  /** Maximum turn storage */
  maxTurns: number;
  /** Last turn regeneration timestamp */
  lastTurnRegen: bigint;
  /** Last battle/action timestamp */
  lastBattle: bigint;
  /** Total battles fought */
  battlesFought: number;
  /** Battles won */
  wins: number;
  /** Battles lost */
  losses: number;
  /** Rewards earned this round */
  rewardsEarned: bigint;
  /** Whether rewards have been claimed */
  rewardsClaimed: boolean;
  /** When player joined the round */
  joinedAt: bigint;
  /** Last idle decay application */
  lastDecay: bigint;
  /** Entry fee paid (for late join tracking) */
  entryFeePaid: bigint;
  /** Bump seed for PDA */
  bump: number;
};

export type PlayerStateArgs = {
  /** Player's wallet address */
  player: Address;
  /** Reference to the game round */
  round: Address;
  /** Strength attribute (damage output) */
  strength: number;
  /** Speed attribute (turn order, dodge chance) */
  speed: number;
  /** Endurance attribute (HP, damage absorption) */
  endurance: number;
  /** Luck attribute (crit chance, steal success) */
  luck: number;
  /** Current available turns */
  turns: number;
  /** Maximum turn storage */
  maxTurns: number;
  /** Last turn regeneration timestamp */
  lastTurnRegen: number | bigint;
  /** Last battle/action timestamp */
  lastBattle: number | bigint;
  /** Total battles fought */
  battlesFought: number;
  /** Battles won */
  wins: number;
  /** Battles lost */
  losses: number;
  /** Rewards earned this round */
  rewardsEarned: number | bigint;
  /** Whether rewards have been claimed */
  rewardsClaimed: boolean;
  /** When player joined the round */
  joinedAt: number | bigint;
  /** Last idle decay application */
  lastDecay: number | bigint;
  /** Entry fee paid (for late join tracking) */
  entryFeePaid: number | bigint;
  /** Bump seed for PDA */
  bump: number;
};

/** Gets the encoder for {@link PlayerStateArgs} account data. */
export function getPlayerStateEncoder(): FixedSizeEncoder<PlayerStateArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['player', getAddressEncoder()],
      ['round', getAddressEncoder()],
      ['strength', getU16Encoder()],
      ['speed', getU16Encoder()],
      ['endurance', getU16Encoder()],
      ['luck', getU16Encoder()],
      ['turns', getU8Encoder()],
      ['maxTurns', getU8Encoder()],
      ['lastTurnRegen', getI64Encoder()],
      ['lastBattle', getI64Encoder()],
      ['battlesFought', getU16Encoder()],
      ['wins', getU16Encoder()],
      ['losses', getU16Encoder()],
      ['rewardsEarned', getU64Encoder()],
      ['rewardsClaimed', getBooleanEncoder()],
      ['joinedAt', getI64Encoder()],
      ['lastDecay', getI64Encoder()],
      ['entryFeePaid', getU64Encoder()],
      ['bump', getU8Encoder()],
    ]),
    (value) => ({ ...value, discriminator: PLAYER_STATE_DISCRIMINATOR })
  );
}

/** Gets the decoder for {@link PlayerState} account data. */
export function getPlayerStateDecoder(): FixedSizeDecoder<PlayerState> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['player', getAddressDecoder()],
    ['round', getAddressDecoder()],
    ['strength', getU16Decoder()],
    ['speed', getU16Decoder()],
    ['endurance', getU16Decoder()],
    ['luck', getU16Decoder()],
    ['turns', getU8Decoder()],
    ['maxTurns', getU8Decoder()],
    ['lastTurnRegen', getI64Decoder()],
    ['lastBattle', getI64Decoder()],
    ['battlesFought', getU16Decoder()],
    ['wins', getU16Decoder()],
    ['losses', getU16Decoder()],
    ['rewardsEarned', getU64Decoder()],
    ['rewardsClaimed', getBooleanDecoder()],
    ['joinedAt', getI64Decoder()],
    ['lastDecay', getI64Decoder()],
    ['entryFeePaid', getU64Decoder()],
    ['bump', getU8Decoder()],
  ]);
}

/** Gets the codec for {@link PlayerState} account data. */
export function getPlayerStateCodec(): FixedSizeCodec<
  PlayerStateArgs,
  PlayerState
> {
  return combineCodec(getPlayerStateEncoder(), getPlayerStateDecoder());
}

export function decodePlayerState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<PlayerState, TAddress>;
export function decodePlayerState<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<PlayerState, TAddress>;
export function decodePlayerState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<PlayerState, TAddress> | MaybeAccount<PlayerState, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getPlayerStateDecoder()
  );
}

export async function fetchPlayerState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<PlayerState, TAddress>> {
  const maybeAccount = await fetchMaybePlayerState(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybePlayerState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<PlayerState, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodePlayerState(maybeAccount);
}

export async function fetchAllPlayerState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<PlayerState>[]> {
  const maybeAccounts = await fetchAllMaybePlayerState(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybePlayerState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<PlayerState>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodePlayerState(maybeAccount));
}

export function getPlayerStateSize(): number {
  return 138;
}
